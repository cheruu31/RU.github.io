<!DOCTYPE html>
<html class="dark" lang="en">

<head>
    <meta charset="utf-8" />
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" name="viewport" />
    <title>CAT RHYTHM - Rhythm Game</title>
    <!-- Fonts & Icons -->
    <link href="https://fonts.googleapis.com" rel="preconnect" />
    <link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect" />
    <link
        href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;400;500;700&family=Noto+Sans:wght@400;500;700&display=swap"
        rel="stylesheet" />
    <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:wght,FILL@100..700,0..1&display=swap"
        rel="stylesheet" />

    <!-- Three.js Import Map -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com?plugins=forms,container-queries"></script>
    <script id="tailwind-config">
        tailwind.config = {
            darkMode: "class",
            theme: {
                extend: {
                    colors: {
                        "primary": "#25c0f4",
                        "background-dark": "#101e22",
                        "neon-pink": "#ff00ff",
                        "neon-yellow": "#facc15"
                    },
                    fontFamily: {
                        "display": ["Space Grotesk", "sans-serif"],
                        "body": ["Noto Sans", "sans-serif"]
                    }
                },
            },
        }
    </script>
    <style>
        .neon-text {
            text-shadow: 0 0 10px rgba(37, 192, 244, 0.8);
        }

        .glass-panel {
            background: rgba(16, 30, 34, 0.6);
            backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        /* Rhythm Game Styles */
        .arrow-frame {
            width: 70px;
            height: 70px;
            border: 2px solid rgba(37, 192, 244, 0.5);
            border-radius: 12px;
            position: absolute;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(37, 192, 244, 0.05);
            transition: transform 0.1s, border-color 0.2s;
            z-index: 20;
            touch-action: none;
        }

        .arrow-frame.hit {
            transform: scale(1.1);
            border-color: white;
        }

        @keyframes popOut {
            0% {
                transform: scale(0.5);
                opacity: 0;
            }

            20% {
                transform: scale(1.2);
                opacity: 1;
            }

            100% {
                transform: translateY(-50px) scale(1);
                opacity: 0;
            }
        }

        /* Cat Frames at Bottom */
        .cat-frame {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            border: 4px solid transparent;
            transition: all 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            background: #283539;
        }

        .frame-blue {
            border-color: #25c0f4;
            box-shadow: 0 0 15px rgba(37, 192, 244, 0.5);
        }

        .frame-yellow {
            border-color: #facc15;
            box-shadow: 0 0 15px rgba(250, 204, 21, 0.5);
        }

        .frame-red {
            border-color: #ef4444;
            box-shadow: 0 0 15px rgba(239, 68, 68, 0.5);
        }

        .jump-anim {
            animation: jump 0.4s infinite alternate;
        }

        @keyframes jump {
            from {
                transform: translateY(0);
            }

            to {
                transform: translateY(-10px);
            }
        }

        #model-status {
            transition: opacity 1s;
        }

        /* Note Styles */
        .note {
            position: absolute;
            background: linear-gradient(135deg, #25c0f4, #00f2fe);
            border: 2px solid white;
            border-radius: 12px;
            pointer-events: none;
            z-index: 30;
            transform: translate(-50%, -50%);
            width: 60px;
            height: 60px;
            box-shadow: 0 0 10px rgba(37, 192, 244, 0.4);
        }

        .note-long {
            box-shadow: 0 0 15px rgba(37, 192, 244, 0.8), inset 0 0 10px rgba(255, 255, 255, 0.4);
            transition: background 0.15s ease, box-shadow 0.15s ease, opacity 0.2s;
        }

        @keyframes pulseActive {
            0% {
                transform: scale(1);
                filter: brightness(1);
            }

            50% {
                transform: scale(1.05);
                filter: brightness(1.3);
            }

            100% {
                transform: scale(1);
                filter: brightness(1);
            }
        }

        .note-active {
            background: linear-gradient(to bottom, #facc15, #ffeb3b) !important;
            box-shadow: 0 0 30px rgba(250, 204, 21, 0.9), inset 0 0 15px rgba(255, 255, 255, 0.6) !important;
            border-color: #ffffff !important;
            opacity: 1 !important;
            animation: pulseActive 0.3s ease-in-out infinite;
        }

        .hit-ripple {
            position: absolute;
            border-radius: 50%;
            border: 4px solid #25c0f4;
            animation: ripple 0.4s ease-out forwards;
            pointer-events: none;
            z-index: 45;
        }

        .floating-score {
            position: absolute;
            color: #facc15;
            font-weight: 800;
            font-size: 1.4rem;
            pointer-events: none;
            z-index: 100;
            text-shadow: 0 0 10px rgba(250, 204, 21, 0.8);
            font-family: 'Space Grotesk', sans-serif;
            font-style: italic;
            animation: floatUpFade 0.7s cubic-bezier(0.165, 0.84, 0.44, 1) forwards;
        }

        @keyframes floatUpFade {
            0% {
                transform: translate(-50%, 0) scale(0.5);
                opacity: 0;
            }

            20% {
                transform: translate(-50%, -20px) scale(1.2);
                opacity: 1;
            }

            100% {
                transform: translate(-50%, -60px) scale(1);
                opacity: 0;
            }
        }

        @keyframes ripple {
            0% {
                width: 0;
                height: 0;
                opacity: 1;
                border-width: 8px;
            }

            100% {
                width: 140px;
                height: 140px;
                opacity: 0;
                border-width: 1px;
            }
        }

        /* Portrait Adaptations */
        @media (max-aspect-ratio: 1/1) {
            .arrow-frame {
                scale: 0.85;
            }

            #frame-left {
                left: 10% !important;
                bottom: 60% !important;
            }

            #frame-top {
                left: 50% !important;
                bottom: 75% !important;
            }

            #frame-right {
                right: 10% !important;
                bottom: 60% !important;
            }

            .cat-frame {
                width: 60px;
                height: 60px;
            }
        }
    </style>
</head>

<body class="bg-background-dark text-white font-display min-h-[100dvh] w-full relative select-none">

    <!-- 3D Background & Models -->
    <div id="canvas-container" class="absolute inset-0 z-0 pointer-events-none"></div>

    <!-- UI Overlay Layer -->
    <div class="relative z-50 flex min-h-[100dvh] flex-col w-full mx-auto pointer-events-none">
        <!-- Top Nav -->
        <div class="flex items-center p-4 justify-between pointer-events-auto">
            <button onclick="window.location.href='pause.html'"
                class="text-white flex size-12 items-center justify-center rounded-full glass-panel hover:bg-white/10 active:scale-95 transition-all">
                <span class="material-symbols-outlined text-3xl">pause</span>
            </button>
            <div class="flex flex-col items-center">
                <h2 class="text-primary text-xl font-bold leading-tight tracking-[0.2em] italic neon-text uppercase">Cat
                    Rhythm</h2>
                <div class="h-1 w-12 bg-gradient-to-r from-transparent via-primary to-transparent mt-1"></div>
            </div>
            <button onclick="window.location.href='menu.html?from=play'"
                class="flex w-12 items-center justify-center size-12 rounded-full glass-panel hover:bg-white/10 active:scale-95 transition-all">
                <span class="material-symbols-outlined text-[#9cb2ba]">menu</span>
            </button>
        </div>

        <!-- Scoreboard -->
        <div class="px-4 pb-2">
            <div
                class="flex items-center justify-between glass-panel rounded-xl p-4 shadow-xl border-t border-white/20">
                <div class="flex flex-col items-start gap-1">
                    <p class="text-[#9cb2ba] text-xs font-bold tracking-widest uppercase">Score</p>
                    <p id="score-val" class="text-white tracking-widest text-2xl font-bold font-mono">0</p>
                </div>
                <div class="h-8 w-[1px] bg-white/10"></div>
                <div class="flex flex-col items-end gap-1">
                    <p class="text-[#9cb2ba] text-xs font-bold tracking-widest uppercase">Combo</p>
                    <p id="combo-val" class="text-neon-yellow tracking-tight text-3xl font-black italic neon-text">0</p>
                </div>
            </div>
        </div>

        <!-- Game Interaction Area (Landscape Optimized) -->
        <div id="game-area" class="flex-1 relative pointer-events-auto">
            <!-- Arrow Frames distributed for landscape grip and avoiding model -->
            <div id="frame-left" class="arrow-frame" style="left: 30%; bottom: 55%">
                <span class="material-symbols-outlined text-4xl opacity-40">keyboard_arrow_left</span>
            </div>
            <div id="frame-top" class="arrow-frame" style="left: 50%; bottom: 80%; transform: translateX(-50%)">
                <span class="material-symbols-outlined text-4xl opacity-40">keyboard_arrow_up</span>
            </div>
            <div id="frame-right" class="arrow-frame" style="right: 30%; bottom: 55%">
                <span class="material-symbols-outlined text-4xl opacity-40">keyboard_arrow_right</span>
            </div>
        </div>

        <!-- Bottom Feedback Area -->
        <div class="mt-auto px-4 pb-8 flex flex-col items-center gap-6">
            <p id="feedback-label"
                class="text-4xl font-black tracking-[0.2em] italic text-primary uppercase opacity-0 transition-all duration-150 transform scale-50">
                Fantastic!</p>
            <div class="flex items-center justify-center gap-8 h-12 relative w-full">
            </div>
        </div>

        <!-- Countdown Overlay (Hidden for now) -->
        <div id="countdown-overlay"
            class="absolute inset-0 flex items-center justify-center pointer-events-none z-[60] hidden">
            <span id="countdown-text" class="text-white text-8xl font-black italic neon-text opacity-0"></span>
        </div>
    </div>

    <!-- Status Overlay -->
    <div id="model-status" class="fixed top-20 left-4 z-[100] pointer-events-none hidden">
        <div class="bg-black/60 backdrop-blur text-white p-2 rounded text-[10px] font-mono border border-white/10">
            <span id="status-text">INITIALIZING...</span>
        </div>
    </div>

    <!-- Three.js Module -->
    <script type="module">
        import * as THREE from 'three';
        import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';

        const statusText = document.getElementById('status-text');
        const updateStatus = (m) => statusText.textContent = m.toUpperCase();

        const CONFIG = {
            HIT_WINDOW: 0.15,
            PERFECT_WINDOW: 0.065,
            SPAWN_INTERVAL: 600,
            NOTE_SPEED: 0.012, // Speed as percentage progress per frame
            COMBO_MULTIPLIER: 0.1,
            GAME_DURATION: 60000
        };

        let state = {
            score: 0,
            combo: 0,
            activeCat: null,
            isGameOver: false,
            isIdling: false,
            isPopAppearing: false,
            popStartTime: 0,
            notes: [],
            lastSpawnTime: 0,
            keysDown: { left: false, top: false, right: false },
            isLongPressing: { left: false, top: false, right: false },
            stats: { perfect: 0, normal: 0, miss: 0, maxCombo: 0, totalNotes: 0 },
            consecutivePerfect: 0,
            consecutiveNonPerfect: 0,
            consecutiveMiss: 0,
            consecutiveNonMiss: 0,
            hitImpact: { x: 0, y: 0, rotationZ: 0 },
            isBowing: false,
            confetti: [],
            sound: null,
            analyser: null,
            beatEnergyHistory: [],
            beatThreshold: 1.25 // Sensitivity for peak detection
        };

        const scoreEl = document.getElementById('score-val');
        const comboEl = document.getElementById('combo-val');
        const feedbackEl = document.getElementById('feedback-label');

        // --- Three.js ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x101e22, 0.0015);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 3000);
        // Optimized view for larger, forwarded model
        camera.position.set(0, 320, 650);
        camera.lookAt(0, 260, 50);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true; // Enable Shadows
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        const ambiLight = new THREE.AmbientLight(0xffffff, 1.4); // Further brightened
        scene.add(ambiLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.8); // Further brightened
        dirLight.position.set(100, 400, 300);
        scene.add(dirLight);

        // Subject Fill Light - Dedicated to the cat
        const fillLight = new THREE.PointLight(0xffffff, 2, 800);
        fillLight.position.set(0, 350, 400);
        scene.add(fillLight);

        // Audio System
        const listener = new THREE.AudioListener();
        camera.add(listener);

        const music = new THREE.Audio(listener);
        state.sound = music;

        // Setup Analyser for Beat Detection
        const analyser = listener.context.createAnalyser();
        analyser.fftSize = 256;
        music.getOutput().connect(analyser);
        state.analyser = analyser;

        const audioLoader = new THREE.AudioLoader();
        audioLoader.load('music/m1.m4a', (buffer) => {
            music.setBuffer(buffer);
            music.setLoop(false);
            music.setVolume(0.5);
            updateStatus("Music Loaded");
        });

        // Dynamic Spotlights - Intense
        const spotLight1 = new THREE.SpotLight(0x25c0f4, 12, 1600, 0.5, 0.5, 1);
        spotLight1.position.set(-200, 600, 200);
        spotLight1.castShadow = true;
        scene.add(spotLight1);

        const spotLight2 = new THREE.SpotLight(0xff00ff, 10, 1500, 0.5, 0.5, 1);
        spotLight2.position.set(200, 600, 200);
        spotLight2.castShadow = true;
        scene.add(spotLight2);

        // --- Stage Elements (Lifted by 150) ---
        // 1. Solid Stage Platform (Cylinder)
        const floorGeo = new THREE.CylinderGeometry(250, 260, 20, 64);
        const floorMat = new THREE.MeshStandardMaterial({
            color: 0x1a2b2e,
            roughness: 0.2,
            metalness: 0.8,
            transparent: true,
            opacity: 0.9
        });
        const floor = new THREE.Mesh(floorGeo, floorMat);
        floor.position.y = 55; // Lowered from 85
        floor.receiveShadow = true;
        scene.add(floor);

        // Stage top glow layer
        const topGlowGeo = new THREE.CircleGeometry(250, 64);
        const topGlowMat = new THREE.MeshPhongMaterial({ color: 0x25c0f4, transparent: true, opacity: 0.15 });
        const topGlow = new THREE.Mesh(topGlowGeo, topGlowMat);
        topGlow.rotation.x = -Math.PI / 2;
        topGlow.position.y = 65.5; // Lowered from 95.5
        scene.add(topGlow);

        // 2. Neon Ring
        const ringGeo = new THREE.TorusGeometry(250, 2, 16, 100);
        const ringMat = new THREE.MeshBasicMaterial({ color: 0x25c0f4 });
        const ring = new THREE.Mesh(ringGeo, ringMat);
        ring.rotation.x = -Math.PI / 2;
        ring.position.y = 66; // Lowered from 96
        scene.add(ring);

        // 3. Simple Grid
        const grid = new THREE.GridHelper(3000, 60, 0x25c0f4, 0x1a2b2e);
        grid.position.y = 50; // Lowered from 80
        scene.add(grid);

        // --- Decorative Background Elements ---
        // 4. Particle System (Neo Dust)
        const particlesCount = 1000;
        const posArr = new Float32Array(particlesCount * 3);
        for (let i = 0; i < particlesCount * 3; i++) posArr[i] = (Math.random() - 0.5) * 2000;
        const particlesGeo = new THREE.BufferGeometry();
        particlesGeo.setAttribute('position', new THREE.BufferAttribute(posArr, 3));
        const particlesMat = new THREE.PointsMaterial({ color: 0x25c0f4, size: 2, transparent: true, opacity: 0.6 });
        const particles = new THREE.Points(particlesGeo, particlesMat);
        scene.add(particles);

        // 5. Floating Cubes / Pyramids
        const backgroundProps = new THREE.Group();
        const propGeo = new THREE.BoxGeometry(20, 20, 20);
        const propMat = new THREE.MeshPhongMaterial({ color: 0x25c0f4, wireframe: true, transparent: true, opacity: 0.3 });
        for (let i = 0; i < 20; i++) {
            const mesh = new THREE.Mesh(propGeo, propMat);
            mesh.position.set((Math.random() - 0.5) * 1000, Math.random() * 500 + 100, (Math.random() - 0.5) * 1000);
            mesh.rotation.set(Math.random(), Math.random(), Math.random());
            backgroundProps.add(mesh);
        }
        scene.add(backgroundProps);

        const models = {
            CYBERCAT: { path: 'model/cybercat.fbx', object: null, mixer: null, img: 'https://lh3.googleusercontent.com/aida-public/AB6AXuBxcb-j7JwWiGBLGXFZq2rH5oTcZTFL3a8MbCCvqL_FU4qlzNWa7ZRgIZ1iorR2yOkvocMwTEH4f-BawyAm-ac_mRGPkVBBX56tgS0uGmHY8AfMt35ZO7g2XQ7iogw8WBodCups80fM2sRtx1fPMDIF5mq3AOzo1ug9_5nGxIrF0LsjXXeGEBaEq1X0jALKruCxGSUa2RKXjG1xEx_st8VwL8Dovy_KL5Nxlqcd27rKd-av8ohxW78w9fHDWz4efZ7Xbif3rf9wlqSj' },
            YELLOW: { path: 'model/yellowcat.fbx', object: null, mixer: null, img: 'https://lh3.googleusercontent.com/aida-public/AB6AXuCZZRiHbOd6-KAW55PESBUTj3h8RhoORAjmdTGpLf9-OnyXLxuKSuFkmK6OfvPGJoRkHzw3-Iq3Tpzmev3UrI1JN8k3IECS_dKHy0H8vET2KI5wiFEip4htu4W9YQelNl9sbWkKEAFo1rIooMV8DxKmKVCEu4m4e84Tw4tduqXqzBKFBoGS3GtCTx352FaWpfZj-Sl38IO4tUE2_vY8bh7RBC-i4e4XdS6glgtRXEu2sqTf5Cx_tx2PoyRl-y0Xt17cVauSzePQ9iZp' },
            RED: { path: 'model/redcat.fbx', object: null, mixer: null, img: 'https://lh3.googleusercontent.com/aida-public/AB6AXuDws7doFdyINvr9dy7pXKNhdWq9qm-zEd3PXY4XZzB6_h_B9j_NFG7d6ux0Ulflgj-Qpc9t68rnFd9yDZ-KFO6olAgFLNtIL_rvQCeD_fqsswT65nwoWux5b05w8RZCC1JAMx_YMOtlWd42nrfHvDTDZrwjXZhwWCOQJZli_Pof56pUsjHVSCrLM5fhNXEx50t3zoAi4SXxf-3VSTl0u724n3EnbXPRXEHZts2e31ixA2P0LFpaBt7TuI0xv1pAmQvFcXcKtMymPC76' }
        };

        const loader = new FBXLoader();
        let loadedCount = 0;

        function loadAllModels() {
            Object.keys(models).forEach(key => {
                loader.load(models[key].path, (fbx) => {
                    fbx.traverse(child => {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                            // Brighten material
                            if (child.material) {
                                if (Array.isArray(child.material)) {
                                    child.material.forEach(m => {
                                        m.emissive = new THREE.Color(0x444444); // Boosted
                                        m.emissiveIntensity = 1.2;
                                    });
                                } else {
                                    child.material.emissive = new THREE.Color(0x444444);
                                    child.material.emissiveIntensity = 1.2;
                                }
                            }
                        }
                    });

                    const box = new THREE.Box3().setFromObject(fbx);
                    const size = box.getSize(new THREE.Vector3());
                    const maxDim = Math.max(size.x, size.y, size.z);
                    const scaleFactor = 160 / maxDim;
                    const finalScale = scaleFactor * 1.5;
                    fbx.scale.set(finalScale, finalScale, finalScale);
                    fbx.userData.baseScale = finalScale; // Store original calculated scale

                    // Requirement: rotate another 90 degrees to the right (Total 270 degrees)
                    fbx.rotation.y = Math.PI * 1.5;

                    fbx.visible = false;
                    models[key].object = fbx;
                    if (fbx.animations.length > 0) {
                        models[key].mixer = new THREE.AnimationMixer(fbx);
                        // Store the default clip
                        models[key].action = models[key].mixer.clipAction(fbx.animations[0]);
                        models[key].action.play();
                    }
                    scene.add(fbx);
                    loadedCount++;
                    if (loadedCount === Object.keys(models).length) {
                        // --- GPU Warm-up / Pre-compile ---
                        // Force a render of all models to avoid stutter during gameplay
                        Object.keys(models).forEach(k => { if (models[k].object) models[k].object.visible = true; });
                        renderer.compile(scene, camera);
                        renderer.render(scene, camera);
                        Object.keys(models).forEach(k => { if (models[k].object) models[k].object.visible = false; });
                        // --- End Warm-up ---

                        updateStatus("Ready");
                        switchCat('CYBERCAT');
                        setTimeout(startEnteringGame, 1000); // Start countdown after load
                    }
                }, undefined, (e) => console.error(e));
            });
        }

        function switchCat(target) {
            if (state.activeCat === target && !state.isGameOver) return;
            if (state.isGameOver) return;

            Object.keys(models).forEach(k => { if (models[k].object) models[k].object.visible = false; });

            state.activeCat = target;
            const model = models[target].object;
            if (model) {
                model.visible = true;
                model.position.set(0, 195, 120);
                triggerPopUp();
            }

            feedbackEl.style.opacity = '0';

            if (target === 'YELLOW') {
                feedbackEl.textContent = 'FANTASTIC';
                feedbackEl.style.opacity = '1';
            } else if (target === 'RED') {
                feedbackEl.textContent = 'OUCH!';
                feedbackEl.style.opacity = '1';
            }
        }

        function triggerPopUp() {
            const model = models[state.activeCat].object;
            if (model) {
                state.isPopAppearing = true;
                state.popStartTime = clock.elapsedTime;
            }
        }

        function triggerDanceResponse(direction) {
            // Instead of direct position rewrite, we apply "impact" that decays
            if (direction === 'top') {
                state.hitImpact.y -= 30; // Direct upward bump
            } else if (direction === 'left') {
                state.hitImpact.x -= 20;
                state.hitImpact.rotationZ += 0.3;
            } else if (direction === 'right') {
                state.hitImpact.x += 20;
                state.hitImpact.rotationZ -= 0.3;
            }
        }

        function playDigitalSound(freq, duration) {
            if (!state.sound || !state.sound.context) return;
            const ctx = state.sound.context;
            const osc = ctx.createOscillator();
            const gain = ctx.createGain();

            osc.type = 'sine';
            osc.frequency.setValueAtTime(freq, ctx.currentTime);

            gain.gain.setValueAtTime(0.2, ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + duration);

            osc.connect(gain);
            gain.connect(ctx.destination);

            osc.start();
            osc.stop(ctx.currentTime + duration);
        }

        function playMeowSound() {
            if (!state.sound || !state.sound.context) return;
            const ctx = state.sound.context;

            const playOneMeow = (delay, pitch) => {
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();

                osc.type = 'triangle';
                const now = ctx.currentTime + delay;

                // Frequency sweep for a "meow" timbre
                osc.frequency.setValueAtTime(pitch, now);
                osc.frequency.exponentialRampToValueAtTime(pitch * 0.7, now + 0.15);
                osc.frequency.exponentialRampToValueAtTime(pitch * 1.1, now + 0.5);

                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(0.1, now + 0.05);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.6);

                osc.connect(gain);
                gain.connect(ctx.destination);

                osc.start(now);
                osc.stop(now + 0.6);
            };

            // Play three meows for the three cats
            playOneMeow(0, 600);
            playOneMeow(0.15, 750);
            playOneMeow(0.3, 550);
        }

        function startEnteringGame() {
            updateStatus("Prepare!");
            const overlay = document.getElementById('countdown-overlay');
            const text = document.getElementById('countdown-text');
            overlay.classList.remove('hidden');

            let count = 3;
            const runCount = () => {
                if (count > 0) {
                    text.textContent = count;
                    text.style.opacity = '1';
                    text.style.transform = 'scale(2)';

                    playDigitalSound(440, 0.15); // Normal Beep

                    setTimeout(() => {
                        text.style.opacity = '0';
                        text.style.transform = 'scale(1)';
                    }, 800);
                    count--;
                    setTimeout(runCount, 1000);
                } else {
                    text.textContent = "GO!";
                    text.style.opacity = '1';
                    text.style.transform = 'scale(2)';

                    playDigitalSound(880, 0.3); // High Beep for GO!

                    // Trigger Pop-up
                    triggerPopUp();

                    // IMMEDIATE START (No Delay)
                    overlay.classList.add('hidden');
                    updateStatus("Playing");
                    state.isIdling = true;

                    // Start Music
                    if (state.sound && state.sound.buffer) {
                        state.sound.play();
                    }

                    // Game Timer
                    setTimeout(endGame, CONFIG.GAME_DURATION);
                }
            };
            runCount();
        }

        function endGame() {
            if (state.isGameOver) return;
            state.isGameOver = true;
            state.isIdling = false;
            updateStatus("Game Over");

            // Stop Music
            if (state.sound && state.sound.isPlaying) {
                state.sound.stop();
            }

            // Clear existing notes from screen
            state.notes.forEach(note => {
                if (note.el) note.el.remove();
            });
            state.notes = [];

            // Hide feedback label
            feedbackEl.style.opacity = '0';
            feedbackEl.style.transform = 'scale(0.5)';

            // Hide arrow frames
            ['left', 'top', 'right'].forEach(lane => {
                const frame = document.getElementById(`frame-${lane}`);
                if (frame) frame.style.opacity = '0';
            });

            // Hide background floating cubes
            if (typeof backgroundProps !== 'undefined') {
                backgroundProps.visible = false;
            }

            // Create Confetti
            createConfetti();

            // Show all three cats for the finale
            const isPortrait = window.innerWidth < window.innerHeight;
            const bowScale = isPortrait ? 0.65 : 1.0; // Shrink for mobile portrait
            const bowSpacing = isPortrait ? 110 : 180; // Tighter formation for mobile

            Object.keys(models).forEach(key => {
                const model = models[key].object;
                if (model) {
                    model.visible = true;
                    // Position: Yellow (Left), Cybercat (Center), Red (Right)
                    let posX = 0;
                    if (key === 'YELLOW') posX = -bowSpacing;
                    if (key === 'RED') posX = bowSpacing;

                    model.position.set(posX, 195, 120);

                    // Reset scales to base * bowScale
                    const baseS = (model.userData.baseScale || 1.0) * bowScale;
                    model.scale.set(baseS, baseS, baseS);
                }
            });

            state.isBowing = true;

            // Play Meow!
            playMeowSound();

            // Save results to localStorage
            const results = {
                score: Math.floor(state.score),
                maxCombo: state.stats.maxCombo,
                perfect: state.stats.perfect,
                normal: state.stats.normal,
                miss: state.stats.miss,
                totalNotes: state.stats.totalNotes
            };
            localStorage.setItem('lastGameStats', JSON.stringify(results));

            setTimeout(() => {
                window.location.href = 'over.html';
            }, 3000); // 3 seconds to show bowing
        }

        function createConfetti() {
            const group = new THREE.Group();
            const colors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff, 0x00ffff, 0xffffff];
            const geometry = new THREE.PlaneGeometry(10, 10);

            for (let i = 0; i < 150; i++) {
                const material = new THREE.MeshPhongMaterial({
                    color: colors[Math.floor(Math.random() * colors.length)],
                    side: THREE.DoubleSide
                });
                const mesh = new THREE.Mesh(geometry, material);

                mesh.position.set(
                    (Math.random() - 0.5) * 800,
                    Math.random() * 500 + 400,
                    (Math.random() - 0.5) * 400 + 100
                );
                mesh.rotation.set(Math.random() * 2, Math.random() * 2, Math.random() * 2);

                const speed = Math.random() * 100 + 150;
                const rotSpeed = {
                    x: Math.random() * 2,
                    y: Math.random() * 2,
                    z: Math.random() * 2
                };

                state.confetti.push({ mesh, speed, rotSpeed });
                group.add(mesh);
            }
            scene.add(group);
        }

        function spawnNote() {
            if (state.isGameOver || !state.isIdling) return;

            const lanes = ['left', 'top', 'right'];
            // Mobile Optimization: Stricter overlap check and reduced density
            const isMobile = window.innerWidth < 768;
            const overlapThreshold = isMobile ? 0.4 : 0.25;

            // Filter lanes to avoid overlap: check if any note in the lane is too close to start
            const availableLanes = lanes.filter(lane => {
                // If a note's progress is < threshold, that lane is considered "busy"
                return !state.notes.some(n => n.lane === lane && n.progress < overlapThreshold);
            });

            if (availableLanes.length === 0) return; // Skip if all lanes are busy

            const lane = availableLanes[Math.floor(Math.random() * availableLanes.length)];
            const type = Math.random() > 0.7 ? 'LONG' : 'NORMAL';

            const noteEl = document.createElement('div');
            noteEl.className = `note ${type === 'LONG' ? 'note-long' : 'note-square'}`;
            document.getElementById('game-area').appendChild(noteEl);

            const note = {
                el: noteEl,
                lane: lane,
                type: type,
                progress: 0,
                length: type === 'LONG' ? (Math.random() * 0.5 + 0.3) : 0, // Randomized length 0.3 to 0.8
                hit: false,
                dead: false,
                isActive: false
            };

            // Set initial orientation
            if (type === 'LONG') {
                if (lane === 'top') {
                    noteEl.style.width = '60px';
                } else {
                    noteEl.style.height = '60px';
                }
            }

            state.notes.push(note);
            state.stats.totalNotes++;
        }

        let layout = { rect: null, centerX: 0, centerY: 0, targets: {} };
        function updateLayout() {
            const gameArea = document.getElementById('game-area');
            if (!gameArea) return;
            const rect = gameArea.getBoundingClientRect();
            layout.rect = rect;
            layout.centerX = rect.width / 2;
            layout.centerY = rect.height / 2;
            ['left', 'top', 'right'].forEach(lane => {
                const el = document.getElementById(`frame-${lane}`);
                if (el) {
                    const tRect = el.getBoundingClientRect();
                    layout.targets[lane] = {
                        x: tRect.left - rect.left + tRect.width / 2,
                        y: tRect.top - rect.top + tRect.height / 2
                    };
                }
            });
        }

        function updateNotes(delta) {
            if (!layout.rect) updateLayout();

            state.notes.forEach((note, index) => {
                note.progress += delta * CONFIG.NOTE_SPEED * 150; // Increased speed for better feel

                const target = layout.targets[note.lane];
                if (!target) return;

                // Position calculation: lerp from center to target
                const curX = layout.centerX + (target.x - layout.centerX) * note.progress;
                const curY = layout.centerY + (target.y - layout.centerY) * note.progress;

                note.el.style.left = `${curX}px`;
                note.el.style.top = `${curY}px`;

                if (note.type === 'LONG') {
                    const totalDist = Math.sqrt(Math.pow(target.x - layout.centerX, 2) + Math.pow(target.y - layout.centerY, 2));
                    const visualLength = note.length * totalDist;

                    note.el.style.transform = 'none'; // Override .note { transform: translate(-50%, -50%) }

                    if (note.lane === 'top') {
                        note.el.style.height = `${visualLength}px`;
                        note.el.style.width = '60px';
                        note.el.style.left = `${curX - 30}px`;
                        note.el.style.top = `${curY}px`;
                        note.el.style.transformOrigin = 'top center';
                    } else if (note.lane === 'left') {
                        note.el.style.width = `${visualLength}px`;
                        note.el.style.height = '60px';
                        note.el.style.top = `${curY - 30}px`;
                        note.el.style.left = `${curX}px`;
                        note.el.style.transformOrigin = 'left center';
                    } else { // right
                        note.el.style.width = `${visualLength}px`;
                        note.el.style.height = '60px';
                        note.el.style.top = `${curY - 30}px`;
                        note.el.style.left = `${curX - visualLength}px`;
                        note.el.style.transformOrigin = 'right center';
                    }

                    // Handle Hold Detection and Visual Color Change
                    const isInRange = note.progress > 0.85 && note.progress < 1.05 + note.length;
                    if (state.isLongPressing[note.lane] && isInRange) {
                        note.hit = true;
                        if (!note.isActive) {
                            note.isActive = true;
                            note.el.classList.add('note-active');
                        }
                        state.score += 2;

                        // Visual score feedback
                        scoreEl.classList.add('scale-110');
                        setTimeout(() => scoreEl.classList.remove('scale-110'), 50);

                        // Continuous ripple feedback
                        if (Math.random() > 0.85) createRipple(note.lane);

                        // Floating Score Feedback (+2)
                        if (!note.lastFloatTime || Date.now() - note.lastFloatTime > 120) {
                            showFloatingScore(curX, curY - 40, '+2');
                            note.lastFloatTime = Date.now();
                        }

                        scoreEl.textContent = Math.floor(state.score);
                    } else {
                        if (note.isActive) {
                            note.isActive = false;
                            note.el.classList.remove('note-active');
                        }
                    }
                } else {
                    // Reset NORMAL square to use center transform if needed
                    note.el.style.transform = 'translate(-50%, -50%)';
                    note.el.style.left = `${curX}px`;
                    note.el.style.top = `${curY}px`;
                    // Ensure normal notes never have the active glow
                    if (note.isActive) {
                        note.isActive = false;
                        note.el.classList.remove('note-active');
                    }
                }

                if (note.progress > 1.2 + note.length) {
                    if (!note.hit) handleHitFeedback('MISS');
                    note.dead = true;
                }
            });

            state.notes = state.notes.filter(n => {
                if (n.dead) {
                    n.el.remove();
                    return false;
                }
                return true;
            });

            // Beat Detection & Note Spawning
            let shouldSpawn = false;
            const now = Date.now();

            if (state.analyser && state.sound && state.sound.isPlaying) {
                const dataArray = new Uint8Array(state.analyser.frequencyBinCount);
                state.analyser.getByteFrequencyData(dataArray);

                // Use a wider frequency range for more reliable detection
                let energy = 0;
                const binCount = 12;
                for (let i = 0; i < binCount; i++) {
                    energy += dataArray[i];
                }
                energy /= binCount;

                // Adaptive Thresholding logic
                if (state.beatEnergyHistory.length > 30) state.beatEnergyHistory.shift();
                const avgEnergy = state.beatEnergyHistory.length > 0 ?
                    (state.beatEnergyHistory.reduce((a, b) => a + b) / state.beatEnergyHistory.length) : 50;

                state.beatEnergyHistory.push(energy);

                // Lower threshold to 1.1 for higher sensitivity and set a lower minimum energy (25)
                const isPeak = energy > avgEnergy * 1.1 && energy > 25;

                // Adaptive Cooldown based on device
                const isMobile = window.innerWidth < 768;
                const minSpawnInterval = isMobile ? 350 : 200; // Mobile: 350ms, Desktop: 200ms

                if (isPeak && now - state.lastSpawnTime > minSpawnInterval) {
                    shouldSpawn = true;
                }
            } else if (state.isIdling && !state.isGameOver) {
                // Fallback: spawn every 0.8s if analysis isn't working/ready 
                if (now - state.lastSpawnTime > 800) {
                    shouldSpawn = true;
                }
            }

            if (shouldSpawn) {
                spawnNote();
                state.lastSpawnTime = now;
            }
        }

        function handleHitFeedback(rating, silent = false) {
            if (rating === 'MISS') {
                state.combo = 0;
                state.stats.miss++;

                state.consecutivePerfect = 0;
                state.consecutiveNonPerfect++;
                state.consecutiveMiss++;
                state.consecutiveNonMiss = 0;

                feedbackEl.textContent = 'MISS';
                feedbackEl.style.color = '#ff4b2b';
                feedbackEl.style.opacity = '1';
                feedbackEl.style.transform = 'scale(1.2)';
                setTimeout(() => {
                    feedbackEl.style.opacity = '0';
                    feedbackEl.style.transform = 'scale(0.5)';
                }, 500);
            } else if (!silent) {
                state.combo++;
                if (rating === 'PERFECT') {
                    state.stats.perfect++;
                    state.consecutivePerfect++;
                    state.consecutiveNonPerfect = 0;
                } else {
                    state.stats.normal++;
                    state.consecutivePerfect = 0;
                    state.consecutiveNonPerfect++;
                }

                state.consecutiveMiss = 0;
                state.consecutiveNonMiss++;

                state.score += (rating === 'PERFECT' ? 100 : 50) * (1 + state.combo * CONFIG.COMBO_MULTIPLIER);

                feedbackEl.textContent = rating;
                feedbackEl.style.color = rating === 'PERFECT' ? '#25c0f4' : '#fff';
                feedbackEl.style.opacity = '1';
                feedbackEl.style.transform = 'scale(1.3)';
                setTimeout(() => {
                    feedbackEl.style.opacity = '0';
                    feedbackEl.style.transform = 'scale(0.5)';
                }, 500);
            }

            // Priority Logic for Cat Switching
            if (state.consecutivePerfect >= 2) {
                // Priority 1: 2 Perfects -> Always Yellow
                if (state.activeCat !== 'YELLOW') switchCat('YELLOW');
            } else if (state.consecutiveMiss >= 2) {
                // Priority 2: 2 Misses -> Red (even if it comes from Yellow)
                if (state.activeCat !== 'RED') switchCat('RED');
            } else {
                // Priority 3: Return to Normal Silver Cat (CYBERCAT)
                if (state.activeCat === 'YELLOW' && state.consecutiveNonPerfect >= 3) {
                    switchCat('CYBERCAT');
                } else if (state.activeCat === 'RED' && state.consecutiveNonMiss >= 3) {
                    switchCat('CYBERCAT');
                }
            }

            scoreEl.textContent = Math.floor(state.score);
            comboEl.textContent = state.combo;

            if (state.combo > state.stats.maxCombo) state.stats.maxCombo = state.combo;
        }

        function checkHit(lane) {
            const activeNotes = state.notes.filter(n => n.lane === lane && !n.hit);
            if (activeNotes.length === 0) return;

            const note = activeNotes[0];
            const dist = Math.abs(note.progress - 1.0); // 1.0 is the exact target hitbox

            if (dist < CONFIG.HIT_WINDOW) {
                const rating = dist < CONFIG.PERFECT_WINDOW ? 'PERFECT' : 'NORMAL';
                note.hit = true;
                if (note.type !== 'LONG') note.dead = true;
                handleHitFeedback(rating);
                createRipple(lane);
            }
        }

        function createRipple(lane) {
            const target = document.getElementById(`frame-${lane}`);
            const ripple = document.createElement('div');
            ripple.className = 'hit-ripple';
            target.appendChild(ripple);
            setTimeout(() => ripple.remove(), 400);
        }

        function showFloatingScore(x, y, text) {
            const gameArea = document.getElementById('game-area');
            const el = document.createElement('div');
            el.className = 'floating-score';
            el.textContent = text;
            el.style.left = `${x}px`;
            el.style.top = `${y}px`;
            gameArea.appendChild(el);
            setTimeout(() => el.remove(), 700);
        }

        // Input Listeners
        window.addEventListener('keydown', (e) => {
            if (e.repeat) return;
            let lane = '';
            if (e.key === 'ArrowLeft') lane = 'left';
            if (e.key === 'ArrowUp') lane = 'top';
            if (e.key === 'ArrowRight') lane = 'right';

            if (lane) {
                state.keysDown[lane] = true;
                state.isLongPressing[lane] = true;
                checkHit(lane);
                document.getElementById(`frame-${lane}`).style.transform = lane === 'top' ? 'translateX(-50%) scale(0.9)' : 'scale(0.9)';
            }
        });

        window.addEventListener('keyup', (e) => {
            let lane = '';
            if (e.key === 'ArrowLeft') lane = 'left';
            if (e.key === 'ArrowUp') lane = 'top';
            if (e.key === 'ArrowRight') lane = 'right';

            if (lane) {
                state.keysDown[lane] = false;
                state.isLongPressing[lane] = false;
                document.getElementById(`frame-${lane}`).style.transform = lane === 'top' ? 'translateX(-50%) scale(1)' : 'scale(1)';
            }
        });

        // Touch Listeners for frames
        ['left', 'top', 'right'].forEach(lane => {
            const el = document.getElementById(`frame-${lane}`);
            el.addEventListener('touchstart', (e) => {
                e.preventDefault();
                state.keysDown[lane] = true;
                state.isLongPressing[lane] = true;
                checkHit(lane);
                el.style.transform = lane === 'top' ? 'translateX(-50%) scale(0.9)' : 'scale(0.9)';
            });
            el.addEventListener('touchend', (e) => {
                e.preventDefault();
                state.keysDown[lane] = false;
                state.isLongPressing[lane] = false;
                el.style.transform = lane === 'top' ? 'translateX(-50%) scale(1)' : 'scale(1)';
            });
        });

        function animate3D() {
            requestAnimationFrame(animate3D);
            const delta = clock.getDelta();
            const time = clock.elapsedTime;

            if (state.isIdling && !state.isGameOver) {
                updateNotes(delta);
            }

            // Animate Spotlights
            if (typeof spotLight1 !== 'undefined') {
                spotLight1.position.x = Math.sin(time * 0.5) * 400;
                spotLight1.position.z = Math.cos(time * 0.5) * 400;
            }
            if (typeof spotLight2 !== 'undefined') {
                spotLight2.position.x = Math.sin(time * 0.5 + Math.PI) * 400;
                spotLight2.position.z = Math.cos(time * 0.5 + Math.PI) * 400;
                // Anger Effect for Red Cat
                if (state.activeCat === 'RED') {
                    spotLight2.intensity = 25 + Math.sin(time * 20) * 10;
                } else {
                    spotLight2.intensity = 10;
                }
            }

            // Animate Background Props
            if (typeof backgroundProps !== 'undefined') {
                backgroundProps.children.forEach((prop, i) => {
                    prop.rotation.x += delta * 0.2;
                    prop.rotation.y += delta * 0.3;
                    prop.position.y += Math.sin(time + i) * 0.1;
                });
            }

            // Gentle rotation for particles
            if (typeof particles !== 'undefined') {
                particles.rotation.y += delta * 0.05;
            }

            // Smoothly decay hit impacts (Additive Animation System)
            const decay = Math.pow(0.001, delta); // Fast decay
            state.hitImpact.x *= decay;
            state.hitImpact.y *= decay;
            state.hitImpact.rotationZ *= decay;

            Object.keys(models).forEach(k => {
                const modelData = models[k];
                const modelObj = modelData.object;
                if (modelData.mixer) modelData.mixer.update(delta);

                if (modelObj && modelObj.visible) {
                    // 1. Handle Pop-up Animation
                    if (state.isPopAppearing) {
                        const elapsed = time - state.popStartTime;
                        const duration = 0.5;
                        const baseS = modelObj.userData.baseScale || 1.0;
                        if (elapsed < duration) {
                            const progress = elapsed / duration;
                            const jumpHeight = Math.sin(progress * Math.PI) * 100;
                            modelObj.position.y = 195 + jumpHeight + state.hitImpact.y;
                            const s = baseS + Math.sin(progress * Math.PI) * (baseS * 0.3);
                            modelObj.scale.set(s, s, s);
                        } else {
                            modelObj.position.y = 195 + state.hitImpact.y;
                            modelObj.scale.set(baseS, baseS, baseS);
                            state.isPopAppearing = false;
                        }
                    }

                    // 2. Continuous Nodding / Dancing (Idling)
                    if (state.isIdling && !state.isPopAppearing) {
                        const baseS = modelObj.userData.baseScale || 1.0;
                        const speedFactor = Math.min(8 + state.combo * 0.1, 15);
                        let intensity = 1.0;
                        if (k === 'YELLOW') intensity = 1.8;
                        if (k === 'RED') intensity = 2.5; // Red cat is angry and intense

                        // Base Sway / Bounce + Adaptive Hit Offset
                        modelObj.position.y = 195 + Math.sin(time * (k === 'RED' ? speedFactor * 1.5 : speedFactor)) * (5 * intensity) + state.hitImpact.y;
                        modelObj.rotation.x = Math.sin(time * (k === 'RED' ? speedFactor * 1.5 : speedFactor)) * (0.08 * intensity);

                        // State-specific Animations
                        if (k === 'YELLOW') {
                            modelObj.position.x = Math.sin(time * speedFactor * 0.5) * 25 + state.hitImpact.x;
                            modelObj.rotation.z = Math.sin(time * speedFactor * 0.5) * 0.15 + state.hitImpact.rotationZ;
                            // Pop scale pulse
                            const pulse = baseS + Math.sin(time * speedFactor) * (baseS * 0.05);
                            modelObj.scale.set(pulse, pulse, pulse);
                        } else if (k === 'RED') {
                            // Angry Jitter (Shaking)
                            modelObj.position.x = (Math.random() - 0.5) * 6 + state.hitImpact.x;
                            modelObj.rotation.z = (Math.random() - 0.5) * 0.08 + state.hitImpact.rotationZ;
                            // Aggressive scale pulse
                            const pulse = baseS + Math.sin(time * speedFactor * 2) * (baseS * 0.03);
                            modelObj.scale.set(pulse, pulse, pulse);
                        } else {
                            modelObj.position.x = state.hitImpact.x;
                            modelObj.rotation.z = state.hitImpact.rotationZ;
                            modelObj.scale.set(baseS, baseS, baseS);
                        }
                    }
                }

                // End game bowing animation
                if (state.isBowing && modelData.object && modelData.object.visible) {
                    modelData.object.rotation.x = Math.sin(time * 3) * 0.3 + 0.3;
                }
            });

            // Update Confetti
            if (state.confetti.length > 0) {
                state.confetti.forEach(c => {
                    c.mesh.position.y -= c.speed * delta;
                    c.mesh.rotation.x += c.rotSpeed.x * delta;
                    c.mesh.rotation.y += c.rotSpeed.y * delta;
                    c.mesh.rotation.z += c.rotSpeed.z * delta;
                    // Reset if too low
                    if (c.mesh.position.y < 50) {
                        c.mesh.position.y = 800;
                    }
                });
            }

            renderer.render(scene, camera);
        }
        const clock = new THREE.Clock();
        loadAllModels();
        animate3D();

        window.addEventListener('resize', () => {
            updateLayout();
            camera.aspect = window.innerWidth / window.innerHeight;

            // Adjust camera position/FOV for portrait
            if (camera.aspect < 1) {
                // Portrait: Zoom In (Z=600), Look Lower (Y=200) -> Stage moves UP visually
                camera.fov = 65;
                camera.position.z = 600;
                camera.position.y = 350;
                camera.lookAt(0, 200, 0);
            } else {
                camera.fov = 45;
                camera.position.z = 650;
                camera.position.y = 320;
                camera.lookAt(0, 260, 50); // Standard view
            }

            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Trigger initial resize for camera setup
        window.dispatchEvent(new Event('resize'));
    </script>
</body>

</html>
